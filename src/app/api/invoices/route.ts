import { InvoiceSchema } from "@/lib/validations/validation";
import { ApiResponse } from "@/types/apiResponse";
import { IInvoice } from "@/types/database";
import { NextRequest, NextResponse } from "next/server";

interface InvoiceCreateResponse {
  invoice: IInvoice;
}

export async function GET(request: NextRequest) {
  try {
    // Handle GET request for listing invoices
    const { searchParams } = new URL(request.url);
    const page = parseInt(searchParams.get("page") || "1");
    const limit = parseInt(searchParams.get("limit") || "10");

    // Your database query logic here
    const invoices: IInvoice[] = []; // Replace with actual query

    return NextResponse.json({
      success: true,
      data: { invoices, page, limit },
    });
  } catch (error) {
    console.error("Get Invoices Error:", error);
    return NextResponse.json(
      {
        success: false,
        message: "Internal server error",
      },
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();

    // Validate request body with Zod
    const validation = InvoiceSchema.safeParse(body);

    if (!validation.success) {
      const errors: Record<string, string> = {};
      validation.error.errors.forEach((error) => {
        const path = error.path.join(".");
        errors[path] = error.message;
      });

      return NextResponse.json(
        {
          success: false,
          message: "Validation failed",
          errors,
        } as ApiResponse<InvoiceCreateResponse>,
        { status: 400 }
      );
    }

    const invoiceData = validation.data;

    // Check for duplicate invoice number
    const isDuplicate = await checkInvoiceExists(invoiceData.invoiceNumber);
    if (isDuplicate) {
      return NextResponse.json(
        {
          success: false,
          message: "Invoice number already exists",
          errors: { invoiceNumber: "This invoice number is already in use" },
        } as ApiResponse<InvoiceCreateResponse>,
        { status: 409 }
      );
    }

    // Calculate totals
    const processedInvoice = processInvoiceCalculations(invoiceData);

    // Save to database
    const savedInvoice = await saveInvoice(processedInvoice);

    const response: ApiResponse<InvoiceCreateResponse> = {
      success: true,
      message: "Invoice created successfully",
      data: { invoice: savedInvoice },
    };

    return NextResponse.json(response, { status: 201 });
  } catch (error) {
    console.error("Invoice Creation Error:", error);

    const errorResponse: ApiResponse<InvoiceCreateResponse> = {
      success: false,
      message: "Internal server error",
    };

    return NextResponse.json(errorResponse, { status: 500 });
  }
}

function processInvoiceCalculations(invoice: Invoice): Invoice {
  // Calculate item amounts
  const processedItems = invoice.items.map((item) => ({
    ...item,
    amount: Number((item.quantity * item.rate).toFixed(2)),
  }));

  // Calculate totals
  const subtotal = Number(
    processedItems.reduce((sum, item) => sum + (item.amount || 0), 0).toFixed(2)
  );
  const taxRate = invoice.taxRate || 0;
  const taxAmount = Number((subtotal * taxRate).toFixed(2));
  const totalAmount = Number((subtotal + taxAmount).toFixed(2));

  return {
    ...invoice,
    items: processedItems,
    subtotal,
    taxAmount,
    totalAmount,
  };
}

async function saveInvoice(invoiceData: Invoice): Promise<Invoice> {
  // Replace with your database logic
  // Example with Prisma:
  // const invoice = await prisma.invoice.create({
  //   data: {
  //     ...invoiceData,
  //     status: 'draft',
  //     items: {
  //       create: invoiceData.items
  //     }
  //   },
  //   include: { items: true }
  // });

  const invoice: Invoice = {
    id: Date.now(), // In real app, this would be generated by DB
    ...invoiceData,
    status: "draft",
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString(),
  };

  console.log("Saving invoice:", invoice);
  return invoice;
}
